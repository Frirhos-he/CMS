'use strict';

/* Data Access Object (DAO) module for accessing pages data */

const db = require('./db');
const contentDao = require('./dao-contents'); // module for accessing the pages table in the DB

/*
 * API: pages
 */

// This function retrieves the whole list of pages from the database.
exports.getPages = () => {
  return new Promise((resolve, reject) => {
    const sql = 'SELECT p.id,u.id AS uid,u.username, p.title, p.creationdate, p.publicationdate FROM pages AS p, users AS u WHERE p.authorid = u.id;  ';
    db.all(sql, (err, rows) => {
      if (err) {
        reject(err);
      }
      if(rows.length === 0){
        resolve({error: "No Pages in the database"})
      }
      const pages = rows.map((e) => {
        // WARNING: the database returns only lowercase fields. So, to be compliant with the client-side, we convert "watchdate" to the camelCase version ("watchDate").
        const page = Object.assign({}, e, { creationDate: e.creationdate, publicationDate: e.publicationdate }); // adding camelcase "watchDate"
        delete page.creationdate; // removing lowercase 
        delete page.publicationdate; // removing lowercase
        return page;
      });
      // WARNING: if implemented as if(filters[filter]) returns true also for filter = 'constructor' but then .filterFunction does not exists
      resolve(pages);
    });
  });
};

// This function retrieves pages and the associated userid
exports.getPagesByUserId = (userid) => {
  return new Promise((resolve, reject) => {
    const sql = `
      SELECT p.id, u.username, p.title, p.creationdate, p.publicationdate
      FROM pages AS p, users AS u
      WHERE p.authorid = u.id AND u.id = ?;
    `;
    db.all(sql, [userid], (err, rows) => {
      if (err) {
        reject(err);
      } else if (rows.length === 0) {  // lenght of the array 0 thus return []
        resolve({error:"no pages found"});
      } else {
        const pages = rows.map((e) => {
          // WARNING: the database returns only lowercase fields. So, to be compliant with the client-side, we convert "publicationdate" to the camelCase version ("publicationDate").
          const page = Object.assign({}, e, { creationDate: e.creationdate, publicationDate: e.publicationdate }); // adding camelcase "publicationDate"
          delete page.creationdate; // removing lowercase 
          delete page.publicationdate; // removing lowercase
          return page;
        });
        resolve(pages);
      }
    });
  });
};
  
// This function retrieves a page given its id and the associated contents
exports.getPageByIdAndContents = (pageid) => {
  return new Promise((resolve, reject) => {
    const sql = `
      SELECT p.id, u.id AS uid, p.title, p.creationdate, p.publicationdate
      FROM pages AS p, users AS u
      WHERE p.id = ? AND p.authorid = u.id;
    `;
    db.get(sql, [pageid], (err, page) => {
      if (err) {
        reject(err);
      } else if (page === undefined) {
        resolve({ error: "Page not found" });
      } else {
        const pageObject = {
          id: page.id,
          authorid: page.uid,
          title: page.title,
          creationDate: page.creationdate,
          publicationDate: page.publicationdate,
          contents: []
        };
        contentDao.getContentsByPageId(page.id)
          .then((contents) => {
            if (contents.length === 0) {
              resolve({ error: "Page has no contents" });
            } else {
              pageObject.contents = contents;
              resolve(pageObject);
            }
          })
          .catch((err) => {
            reject(err);
          });
      }
    });
  });
};



  
  
// This function create a page given its properties, autogenerated id and lastID automatically retrieved from the db
exports.createPage = (page) => {
  return new Promise((resolve, reject) => {
    const sql = 'INSERT INTO pages (title, authorid, creationDate, publicationDate) VALUES (?, ?, ?, ?)';
    db.run(sql, [page.title, page.authorid, page.creationDate, page.publicationDate], function (err) {
      if (err) {
        reject(err);
        return;
      }

      const pageId = this.lastID; // id of the newly inserted page

      Promise.all(
        page.contents.map((content) => {
          return contentDao.createContent(content, pageId); // Call createContent function for each content
        })
      )
        .then(() => {
          // Fetch the newly created page with contents from the database
          resolve(exports.getPageByIdAndContents(pageId));
        })
        .catch((error) => {
          reject(error);
        });
    });
  });
};



// This function updates an existing page given its id and adding new properties
exports.updatePage = (pageid, page) => {
  return new Promise((resolve, reject) => {
    const sql = 'UPDATE pages SET title = ?, authorid = ?, creationDate = ?, publicationDate = ? WHERE id = ?';
    db.run(sql, [page.title, page.authorid, page.creationDate, page.publicationDate, pageid], function (err) {
      if (err) {
        reject(err);
        return;
      }
      if (this.changes !== 1) {
        resolve({ error: 'No page was updated.' });
        return;
      }
      contentDao.deleteContentsByPageId(pageid)  // before inserting the contents I need to remove the previosly inserted
        .then(() => {
          const createContentPromises = page.contents.map((content) => {
            return contentDao.createContent(content, pageid);
          });
          return Promise.all(createContentPromises);
        })
        .then(() => {
          resolve(exports.getPageByIdAndContents(pageid));  //return the corrected page
        })
        .catch((error) => {
          reject(error);
        });
    });
  });
};

// This function deletes an existing page given its id.
exports.deletePage = (pageid) => {
  return contentDao.deleteContentsByPageId(pageid)
    .then(() => {
      return new Promise((resolve, reject) => {
        const sql = 'DELETE FROM pages WHERE id = ?';
        db.run(sql, [pageid], function (err) {
          if (err) {
            reject(err);
          }
          if (this.changes !== 1)
            resolve({ error: 'No page deleted.' });
          else
            resolve();
        });
        });
      })
    .catch((error) => {
      reject(error);
    });
};

